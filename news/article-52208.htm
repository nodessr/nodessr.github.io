<!DOCTYPE html>
<html xml:lang="zh-CN" lang="zh-CN">

<head>
        <link rel="canonical" href="https://nodessr.github.io/news/article-52208.htm" />
    <title>Redis 如何保证数据库和缓存双写一致性？</title>
        <meta name="description" content="前言  数据库和缓存（比如：redis）双写数据一致性问题，是一个跟开发语言无关的公共问题。尤其在高并发的场景下，这个问题变得更加严重。 我很负责的告诉大家，该问题无论在面试，还是工作中遇到的概率非常" />
        <link rel="icon" href="/assets/website/img/nodessr/favicon.ico" type="image/x-icon"/>

    <meta name="author" content="Node SSR节点订阅官网">
    <meta property="og:type" content="article" />
    <meta property="og:url" content="https://nodessr.github.io/news/article-52208.htm" />
    <meta property="og:site_name" content="Node SSR节点订阅官网" />
    <meta property="og:title" content="Redis 如何保证数据库和缓存双写一致性？" />
    <meta property="og:image" content="https://nodessr.github.io/uploads/20240819-1/235c4d3379d84c3ebdf2e4f38029119a.webp" />
        <meta property="og:release_date" content="2025-02-06T05:29:57" />
    <meta property="og:updated_time" content="2025-02-06T05:29:57" />
        <meta property="og:description" content="前言  数据库和缓存（比如：redis）双写数据一致性问题，是一个跟开发语言无关的公共问题。尤其在高并发的场景下，这个问题变得更加严重。 我很负责的告诉大家，该问题无论在面试，还是工作中遇到的概率非常" />
        
    <meta name="applicable-device" content="pc,mobile" />
    <meta name="renderer" content="webkit" />
    <meta name="force-rendering" content="webkit" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta name="robots" content="max-image-preview:large" />
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="Redis 如何保证数据库和缓存双写一致性？">
    <meta name="format-detection" content="telephone=no">

    <link rel="dns-prefetch" href="https:/www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googleadservices.com">
    <link rel="dns-prefetch" href="https://www.google-analytics.com">
    <link rel="dns-prefetch" href="https://pagead2.googlesyndication.com">
    <link rel="dns-prefetch" href="https://cm.g.doubleclick.net">
    <link rel="dns-prefetch" href="https://fonts.googleapis.com">
    <link rel="dns-prefetch" href="https://stackpath.bootstrapcdn.com">

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/assets/website/css/nodessr/animate.css">
    <link rel="stylesheet" href="/assets/website/css/nodessr/owl.carousel.min.css">
    <link rel="stylesheet" href="/assets/website/css/nodessr/owl.theme.default.min.css">
    <link rel="stylesheet" href="/assets/website/css/nodessr/magnific-popup.css">
    <link rel="stylesheet" href="/assets/website/css/nodessr/flaticon.css">
    <link rel="stylesheet" href="/assets/website/css/nodessr/style.css">
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-FMQ6KRWLLE"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-FMQ6KRWLLE');
</script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3332997411212854"
     crossorigin="anonymous"></script>
</head>

<body data-page="detail">
        <nav class="navbar navbar-expand-lg navbar-dark ftco_navbar bg-dark ftco-navbar-light" id="ftco-navbar">
        <div class="container">
            <a class="navbar-brand" href="/">
                        <span>Node SSR</span>
                        </a>
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#ftco-nav" aria-controls="ftco-nav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="oi oi-menu"></span> Menu
            </button>
            <div class="collapse navbar-collapse" id="ftco-nav">
                <ul class="navbar-nav ml-auto">
                                        <li class="nav-item"><a href="/" class="nav-link">首页</a></li>
                                        <li class="nav-item"><a href="/free-nodes/" class="nav-link">免费节点</a></li>
                                        <li class="nav-item"><a href="/paid-subscribe/" class="nav-link">推荐机场</a></li>
                                        <li class="nav-item"><a href="/news/" class="nav-link">新闻资讯</a></li>
                                        <li class="nav-item"><a href="#" class="nav-link">关于</a></li>
                    <li class="nav-item"><a href="#" class="nav-link">联系</a></li>
                </ul>
            </div>
        </div>
    </nav>
    <!-- END nav -->
    <section class="hero-wrap hero-wrap-2" style="background-image: url('/assets/website/img/nodessr/bg_5.jpg');" data-stellar-background-ratio="0.5">
        <div class="overlay"></div>
        <div class="container">
            <div class="row no-gutters slider-text align-items-end justify-content-center">
                <div class="col-md-9 ftco-animate mb-5 text-center">
                    <p class="breadcrumbs mb-0">
                        <span class="mr-2"><a href="/">首页 <i class="fa fa-chevron-right"></i></a></span>
                        <span class="mr-2"><a href="/news/">新闻资讯 <i class="fa fa-chevron-right"></i></a></span>
                        <span>正文</span>
                    </p>
                    <h1 class="mb-0 bread">Redis 如何保证数据库和缓存双写一致性？</h1>
                </div>
            </div>
        </div>
    </section>
    <section class="ftco-section ftco-no-pb ftco-no-pt py-5">
        <div class="container">
            <div class="row">
                <div class="col-md-9">
                                    <input type="hidden" id="share-website-info" data-name="" data-url="">
                  				  				  				<div id="content_views" class="htmledit_views"> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">前言</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">数据库和缓存（比如：</span><span style="color:#333333;">redis</span><span style="color:#333333;">）双写数据一致性问题，是一个跟开发语言无关的公共问题。尤其在高并发的场景下，这个问题变得更加严重。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我很负责的告诉大家，该问题无论在面试，还是工作中遇到的概率非常大，所以非常有必要跟大家一起探讨一下。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">今天这篇文章我会从浅入深，跟大家一起聊聊，数据库和缓存双写数据一致性问题常见的解决方案，这些方案中可能存在的坑，以及最优方案是什么。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">1.</span></strong><strong><span style="color:#333333;">常见方案</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">通常情况下，我们使用缓存的主要目的是为了提升查询的性能。大多数情况下，我们是这样使用缓存的：</span><img fetchpriority="high" decoding="async" alt="" height="688" src="http://img.555519.xyz/uploads3/20220821/b13f3922de2d5126ce0f2d01183be98f.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">用户请求过来之后，先查缓存有没有数据，如果有则直接返回。</span></li> <li style="text-align:left;"><span style="color:#333333;">如果缓存没数据，再继续查数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">如果数据库有数据，则将查询出来的数据，放入缓存中，然后返回该数据。</span></li> <li style="text-align:left;"><span style="color:#333333;">如果数据库也没数据，则直接返回空。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这是缓存非常常见的用法。一眼看上去，好像没有啥问题。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但你忽略了一个非常重要的细节：<strong>如果数据库中的某条数据，放入缓存之后，又立马被更新了，那么该如何更新缓存呢？</strong></span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">不更新缓存行不行？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：当然不行，如果不更新缓存，在很长的一段时间内（决定于缓存的过期时间），用户请求从缓存中获取到的都可能是旧值，而非数据库的最新值。这不是有数据不一致的问题？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，我们该如何更新缓存呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">目前有以下</span><span style="color:#333333;">4</span><span style="color:#333333;">种方案：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">先写缓存，再写数据库</span></li> <li style="text-align:left;"><span style="color:#333333;">先写数据库，再写缓存</span></li> <li style="text-align:left;"><span style="color:#333333;">先删缓存，再写数据库</span></li> <li style="text-align:left;"><span style="color:#333333;">先写数据库，再删缓存</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">接下来，我们详细说说这</span><span style="color:#333333;">4</span><span style="color:#333333;">种方案。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">2.</span></strong><strong><span style="color:#333333;">先写缓存，再写数据库</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">对于更新缓存的方案，很多人第一个想到的可能是在写操作中直接更新缓存（写缓存），更直接明了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，问题来了：在写操作中，到底是先写缓存，还是先写数据库呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们在这里先聊聊先写缓存，再写数据库的情况，因为它的问题最严重。</span><img decoding="async" alt="" height="416" src="http://img.555519.xyz/uploads3/20220821/09f58fec7e82f29c3421ec9c418951e8.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">某一个用户的每一次写操作，如果刚写完缓存，突然网络出现了异常，导致写数据库失败了。</span></p> <p style="margin-left:0;text-align:left;"><img decoding="async" alt="" height="416" src="http://img.555519.xyz/uploads3/20220821/8dbff0716fa96166b7eeee89c615fe51.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其结果是缓存更新成了最新数据，但数据库没有，这样缓存中的数据不就变成脏数据了？如果此时该用户的查询请求，正好读取到该数据，就会出现问题，因为该数据在数据库中根本不存在，这个问题非常严重。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们都知道，缓存的主要目的是把数据库的数据临时保存在内存，便于后续的查询，提升查询速度。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果某条数据，在数据库中都不存在，你缓存这种</span><span style="color:#333333;">“</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">假数据</span></span><span style="color:#333333;">”</span><span style="color:#333333;">又有啥意义呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">因此，先写缓存，再写数据库的方案是不可取的，在实际工作中用得不多。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.</span></strong><strong><span style="color:#333333;">先写数据库，再写缓存</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">既然上面的方案行不通，接下来，聊聊先写数据库，再写缓存的方案，该方案在低并发编程中有人在用（我猜的）。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="394" src="http://img.555519.xyz/uploads3/20220821/3fda48f4718eb8c35ac3f54892b979aa.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">用户的写操作，先写数据库，再写缓存，可以避免之前</span><span style="color:#333333;">“</span><span style="color:#333333;">假数据</span><span style="color:#333333;">”</span><span style="color:#333333;">的问题。但它却带来了新的问题。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">什么问题呢？</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.1</span></strong><strong><span style="color:#333333;">写缓存失败了</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果把写数据库和写缓存操作，放在同一个事务当中，当写缓存失败了，我们可以把写入数据库的数据进行回滚。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="406" src="http://img.555519.xyz/uploads3/20220821/04cb2395a578240f067b6b839dc6bc7b.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果是并发量比较小，对接口性能要求不太高的系统，可以这么玩。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果在高并发的业务场景中，写数据库和写缓存，都属于远程操作。为了防止出现大事务，造成的死锁问题，通常建议写数据库和写缓存不要放在同一个事务中。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">也就是说在该方案中，如果写数据库成功了，但写缓存失败了，数据库中已写入的数据不会回滚。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这就会出现：数据库是</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">新数据</span></span><span style="color:#333333;">，而缓存是</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">旧数据</span></span><span style="color:#333333;">，两边</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">数据不一致</span></span><span style="color:#333333;">的情况。</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.1</span></strong><strong><span style="color:#333333;">高并发下的问题</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">假设在高并发的场景中，针对同一个用户的同一条数据，有两个写数据请求：</span><span style="color:#333333;">a</span><span style="color:#333333;">和</span><span style="color:#333333;">b</span><span style="color:#333333;">，它们同时请求到业务系统。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其中请求</span><span style="color:#333333;">a</span><span style="color:#333333;">获取的是旧数据，而请求</span><span style="color:#333333;">b获取的是新数据，如下图所示：</span><img loading="lazy" decoding="async" alt="" height="508" src="http://img.555519.xyz/uploads3/20220821/5cbfd39c881b652d27d3a137eeba0af3.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求a先过来，刚写完了数据库。但由于网络原因，卡顿了一下，还没来得及写缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">这时候请求b过来了，先写了数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">接下来，请求b顺利写了缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">此时，请求a卡顿结束，也写了缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">很显然，在这个过程当中，请求</span><span style="color:#333333;">b</span><span style="color:#333333;">在缓存中的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">新数据</span></span><span style="color:#333333;">，被请求</span><span style="color:#333333;">a</span><span style="color:#333333;">的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">旧数据</span></span><span style="color:#333333;">覆盖了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">也就是说：在高并发场景中，如果多个线程同时执行先写数据库，再写缓存的操作，可能会出现数据库是新值，而缓存中是旧值，两边数据不一致的情况。</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">3.2</span></strong><strong><span style="color:#333333;">浪费系统资源</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">该方案还有一个比较大的问题就是：每个写操作，写完数据库，会马上写缓存，比较</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">浪费系统资源</span></span><span style="color:#333333;">。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">为什么这么说呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">你可以试想一下，如果写的缓存，并不是简单的数据内容，而是要经过非常复杂的计算得出的最终结果。这样每写一次缓存，都需要经过一次非常复杂的计算，不是非常浪费系统资源吗？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">尤其是</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">cpu</span></span><span style="color:#333333;">和</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">内存</span></span><span style="color:#333333;">资源。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">还有些业务场景比较特殊：</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">写多读少</span></span><span style="color:#333333;">。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果在这类业务场景中，每个用的写操作，都需要写一次缓存，有点得不偿失。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">由此可见，在高并发的场景中，先写数据库，再写缓存，这套方案问题挺多的，也不太建议使用。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如果你已经用了，赶紧看看踩坑了没？</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">4.</span></strong><strong><span style="color:#333333;">先删缓存，再写数据库</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">通过上面的内容我们得知，如果直接更新缓存的问题很多。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，为何我们不能换一种思路：不去直接</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">更新缓存</span></span><span style="color:#333333;">，而改为</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">删除缓存</span></span><span style="color:#333333;">呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">删除缓存方案，同样有两种：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">先删缓存，再写数据库</span></li> <li style="text-align:left;"><span style="color:#333333;">先写数据库，再删缓存</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们一起先看看：先删缓存，再写数据库的情况。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="366" src="http://img.555519.xyz/uploads3/20220821/a98c7205f18e8e3b90023e88bf59db56.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">说白了，在用户的写操作中，先执行删除缓存操作，再去写数据库。这套方案，可以是可以，但也会有一样问题。</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">4.1</span></strong><strong><span style="color:#333333;">高并发下的问题</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">假设在高并发的场景中，同一个用户的同一条数据，有一个读数据请求</span><span style="color:#333333;">c</span><span style="color:#333333;">，还有另一个写数据请求</span><span style="color:#333333;">d（一个更新操作），同时请求到业务系统。如下图所示：</span><img loading="lazy" decoding="async" alt="" height="600" src="http://img.555519.xyz/uploads3/20220821/26be493be0b2c015f334acd5dc74f9d2.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求c将数据库中的旧值，更新到缓存中。</span></li> <li style="text-align:left;"><span style="color:#333333;">此时，请求d卡顿结束，把新值写入数据库。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在这个过程当中，请求</span><span style="color:#333333;">d</span><span style="color:#333333;">的新值并没有被请求</span><span style="color:#333333;">c</span><span style="color:#333333;">写入缓存，同样会导致缓存和数据库的数据不一致的情况。更正：图中步骤</span><span style="color:#333333;">7</span><span style="color:#333333;">写入旧值，步骤</span><span style="color:#333333;">9</span><span style="color:#333333;">要删掉。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，这种场景的数据不一致问题，能否解决呢？</span></p> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">4.2</span></strong><strong><span style="color:#333333;">缓存双删</span></strong></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在上面的业务场景中，一个读数据请求，一个写数据请求。当写数据请求把缓存删了之后，读数据请求，可能把当时从数据库查询出来的旧值，写入缓存当中。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">有人说还不好办，请求</span><span style="color:#333333;">d</span><span style="color:#333333;">在写完数据库之后，把缓存重新删一次不就行了？</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="480" src="http://img.555519.xyz/uploads3/20220821/03ba20879d006a017085d65178762977.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这就是我们所说的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">缓存双删</span></span><span style="color:#333333;">，即在写数据库之前删除一次，写完数据库后，再删除一次。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">该方案有个非常关键的地方是：第二次删除缓存，并非立马就删，而是要在一定的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">时间间隔</span></span><span style="color:#333333;">之后。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们再重新回顾一下，高并发下一个读数据请求，一个写数据请求导致数据不一致的产生过程：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求d先过来，把缓存删除了。但由于网络原因，卡顿了一下，还没来得及写数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">这时请求c过来了，先查缓存发现没数据，再查数据库，有数据，但是旧值。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求c将数据库中的旧值，更新到缓存中。</span></li> <li style="text-align:left;"><span style="color:#333333;">此时，请求d卡顿结束，把新值写入数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">一段时间之后，比如：500ms，请求d将缓存删除。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这样来看确实可以解决缓存不一致问题。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，为什么一定要间隔一段时间之后，才能删除缓存呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">请求</span><span style="color:#333333;">d</span><span style="color:#333333;">卡顿结束，把新值写入数据库后，请求</span><span style="color:#333333;">c</span><span style="color:#333333;">将数据库中的旧值，更新到缓存中。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">此时，如果请求</span><span style="color:#333333;">d</span><span style="color:#333333;">删除太快，在请求</span><span style="color:#333333;">c</span><span style="color:#333333;">将数据库中的旧值更新到缓存之前，就已经把缓存删除了，这次删除就没任何意义。必须要在请求</span><span style="color:#333333;">c</span><span style="color:#333333;">更新缓存之后，再删除缓存，才能把旧值及时删除了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">所以需要在请求</span><span style="color:#333333;">d</span><span style="color:#333333;">中加一个时间间隔，确保请求</span><span style="color:#333333;">c</span><span style="color:#333333;">，或者类似于请求</span><span style="color:#333333;">c</span><span style="color:#333333;">的其他请求，如果在缓存中设置了旧值，最终都能够被请求</span><span style="color:#333333;">d</span><span style="color:#333333;">删除掉。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">接下来，还有一个问题：如果第二次删除缓存时，删除失败了该怎么办？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这里先留点悬念，后面会详细说。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">5.</span></strong><strong><span style="color:#333333;">先写数据库，再删缓存</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">从前面得知，先删缓存，再写数据库，在并发的情况下，也可能会出现缓存和数据库的数据不一致的情况。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，我们只能寄希望于最后的方案了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">接下来，我们重点看看先写数据库，再删缓存的方案。</span></p> <p style="margin-left:0;text-align:left;"><img loading="lazy" decoding="async" alt="" height="372" src="http://img.555519.xyz/uploads3/20220821/0cc858241b3170edfa5387f19516f47c.jpg"></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在高并发的场景中，有一个读数据请求，有一个写数据请求，更新过程如下：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求e先写数据库，由于网络原因卡顿了一下，没有来得及删除缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f查询缓存，发现缓存中有数据，直接返回该数据。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e删除缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在这个过程中，只有请求</span><span style="color:#333333;">f</span><span style="color:#333333;">读了一次旧数据，后来旧数据被请求</span><span style="color:#333333;">e</span><span style="color:#333333;">及时删除了，看起来问题不大。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果是读数据请求先过来呢？</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">请求f查询缓存，发现缓存中有数据，直接返回该数据。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e先写数据库。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e删除缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这种情况看起来也没问题呀？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：对的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但就怕出现下面这种情况，即缓存自己失效了。如下图所示：</span><img loading="lazy" decoding="async" alt="" height="568" src="http://img.555519.xyz/uploads3/20220821/0a7eb2ef9caeca69ecf10fc906f4e26b.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">缓存过期时间到了，自动失效。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f查询缓存，发缓存中没有数据，查询数据库的旧值，但由于网络原因卡顿了，没有来得及更新缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求e先写数据库，接着删除了缓存。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f更新旧值到缓存中。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这时，缓存和数据库的数据同样出现不一致的情况了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但这种情况还是比较少的，需要同时满足以下条件才可以：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">缓存刚好自动失效。</span></li> <li style="text-align:left;"><span style="color:#333333;">请求f从数据库查出旧值，更新缓存的耗时，比请求e写数据库，并且删除缓存的还长。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">我们都知道查询数据库的速度，一般比写数据库要快，更何况写完数据库，还要删除缓存。所以绝大多数情况下，写数据请求比读数据情况耗时更长。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">由此可见，系统同时满足上述两个条件的概率非常小。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#777777;">推荐大家使用先写数据库，再删缓存的方案，虽说不能</span><span style="color:#777777;">100%</span><span style="color:#777777;">避免数据不一致问题，但出现该问题的概率，相对于其他方案来说是最小的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但在该方案中，如果删除缓存失败了该怎么办呢？</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">6.</span></strong><strong><span style="color:#333333;">删缓存失败怎么办？</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其实先写数据库，再删缓存的方案，跟缓存双删的方案一样，有一个共同的风险点，即：如果缓存删除失败了，也会导致缓存和数据库的数据不一致。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">那么，删除缓存失败怎么办呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：需要加</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">重试机制</span></span><span style="color:#333333;">。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在接口中如果更新了数据库成功了，但更新缓存失败了，可以立刻重试</span><span style="color:#333333;">3</span><span style="color:#333333;">次。如果其中有任何一次成功，则直接返回成功。如果</span><span style="color:#333333;">3</span><span style="color:#333333;">次都失败了，则写入数据库，准备后续再处理。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">当然，如果你在接口中直接</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">同步重试</span></span><span style="color:#333333;">，该接口并发量比较高的时候，可能有点影响接口性能。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这时，就需要改成</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">异步重试</span></span><span style="color:#333333;">了。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">异步重试方式有很多种，比如：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">每次都单独起一个线程，该线程专门做重试的工作。但如果在高并发的场景下，可能会创建太多的线程，导致系统OOM问题，不太建议使用。</span></li> <li style="text-align:left;"><span style="color:#333333;">将重试的任务交给线程池处理，但如果服务器重启，部分数据可能会丢失。</span></li> <li style="text-align:left;"><span style="color:#333333;">将重试数据写表，然后使用elastic-job等定时任务进行重试。</span></li> <li style="text-align:left;"><span style="color:#333333;">将重试的请求写入mq等消息中间件中，在mq的consumer中处理。</span></li> <li style="text-align:left;"><span style="color:#333333;">订阅mysql的binlog，在订阅者中，如果发现了更新数据请求，则删除相应的缓存。</span></li> </ol> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">7.</span></strong><strong><span style="color:#333333;">定时任务</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">使用</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">定时任务重试</span></span><span style="color:#333333;">的具体方案如下：</span></p> <ol> <li style="text-align:left;"><span style="color:#333333;">当用户操作写完数据库，但删除缓存失败了，需要将用户数据写入重试表中。如下图所示：</span><img loading="lazy" decoding="async" alt="" height="846" src="http://img.555519.xyz/uploads3/20220821/ff3e6bcdc9d8db4fe37e8460ba34a52a.jpg"></li> <li style="text-align:left;"><span style="color:#333333;">在定时任务中，异步读取重试表中的用户数据。重试表需要记录一个重试次数字段，初始值为0。然后重试5次，不断删除缓存，每重试一次该字段值+1。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则我们需要在重试表中记录一个失败的状态，等待后续进一步处理。</span><img loading="lazy" decoding="async" alt="" height="976" src="http://img.555519.xyz/uploads3/20220821/1971301660f79e4a1785b5c07be84001.jpg"></li> <li style="text-align:left;"><span style="color:#333333;">在高并发场景中，定时任务推荐使用<span style="background-color:#f3f4f4;">elastic-job</span>。相对于xxl-job等定时任务，它可以分片处理，提升处理速度。同时每片的间隔可以设置成：1,2,3,5,7秒等。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">使用定时任务重试的话，有个缺点就是实时性没那么高，对于实时性要求特别高的业务场景，该方案不太适用。但是对于一般场景，还是可以用一用的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但它有一个很大的优点，即数据是落库的，不会丢数据。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">8. mq</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在高并发的业务场景中，</span><span style="color:#333333;">mq</span><span style="color:#333333;">（消息队列）是必不可少的技术之一。它不仅可以异步解耦，还能削峰填谷。对保证系统的稳定性是非常有意义的。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">mq</span><span style="color:#333333;">的生产者，生产了消息之后，通过指定的</span><span style="color:#333333;">topic</span><span style="color:#333333;">发送到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器。然后</span><span style="color:#333333;">mq</span><span style="color:#333333;">的消费者，订阅该</span><span style="color:#333333;">topic</span><span style="color:#333333;">的消息，读取消息数据之后，做业务逻辑处理。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">使用</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">mq</span></span><span style="background-color:#f3f4f4;"><span style="color:#333333;">重试</span></span><span style="color:#333333;">的具体方案如下：</span><img loading="lazy" decoding="async" alt="" height="685" src="http://img.555519.xyz/uploads3/20220821/b6d34f4be2ce6acc6774037b2fc13094.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">当用户操作写完数据库，但删除缓存失败了，产生一条mq消息，发送给mq服务器。</span></li> <li style="text-align:left;"><span style="color:#333333;">mq消费者读取mq消息，重试5次删除缓存。如果其中有任意一次成功了，则返回成功。如果重试了5次，还是失败，则写入<span style="background-color:#f3f4f4;">死信队列</span>中。</span></li> <li style="text-align:left;"><span style="color:#333333;">推荐mq使用<span style="background-color:#f3f4f4;">rocketmq</span>，重试机制和死信队列默认是支持的。使用起来非常方便，而且还支持顺序消息，延迟消息和事务消息等多种业务场景。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">当然在该方案中，删除缓存可以完全走异步。即用户的写操作，在写完数据库之后，不用立刻删除一次缓存。而直接发送</span><span style="color:#333333;">mq</span><span style="color:#333333;">消息，到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器，然后有</span><span style="color:#333333;">mq</span><span style="color:#333333;">消费者全权负责删除缓存的任务。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">因为</span><span style="color:#333333;">mq</span><span style="color:#333333;">的实时性还是比较高的，因此改良后的方案也是一种不错的选择。</span></p> <div> <p style="margin-left:0;text-align:left;"><strong><span style="color:#333333;">9. binlog</span></strong></p> </div> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">前面我们聊过的，无论是定时任务，还是</span><span style="color:#333333;">mq</span><span style="color:#333333;">（消息队列），做重试机制，对业务都有一定的侵入性。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在使用定时任务的方案中，需要在业务代码中增加额外逻辑，如果删除缓存失败，需要将数据写入重试表。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">而使用</span><span style="color:#333333;">mq</span><span style="color:#333333;">的方案中，如果删除缓存失败了，需要在业务代码中发送</span><span style="color:#333333;">mq</span><span style="color:#333333;">消息到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">其实，还有一种更优雅的实现，即</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">监听</span></span><span style="background-color:#f3f4f4;"><span style="color:#333333;">binlog</span></span><span style="color:#333333;">，比如使用：</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">canal</span></span><span style="color:#333333;">等中间件。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">具体方案如下：</span><img loading="lazy" decoding="async" alt="" height="427" src="http://img.555519.xyz/uploads3/20220821/fce6eba89d6007ed8f3eaf102d2795fa.jpg"></p> <ol> <li style="text-align:left;"><span style="color:#333333;">在业务接口中写数据库之后，就不管了，直接返回成功。</span></li> <li style="text-align:left;"><span style="color:#333333;">mysql服务器会自动把变更的数据写入binlog中。</span></li> <li style="text-align:left;"><span style="color:#333333;">binlog订阅者获取变更的数据，然后删除缓存。</span></li> </ol> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">这套方案中业务接口确实简化了一些流程，只用关心数据库操作即可，而在</span><span style="color:#333333;">binlog</span><span style="color:#333333;">订阅者中做缓存删除工作。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">但如果只是按照图中的方案进行删除缓存，只删除了一次，也可能会失败。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">如何解决这个问题呢？</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">答：这就需要加上前面聊过的</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">重试机制</span></span><span style="color:#333333;">了。如果删除缓存失败，写入重试表，使用定时任务重试。或者写入</span><span style="color:#333333;">mq</span><span style="color:#333333;">，让</span><span style="color:#333333;">mq</span><span style="color:#333333;">自动重试。</span></p> <p style="margin-left:0;text-align:left;"><span style="color:#333333;">在这里推荐使用</span><span style="background-color:#f3f4f4;"><span style="color:#333333;">mq</span></span><span style="background-color:#f3f4f4;"><span style="color:#333333;">自动重试机制</span></span><span style="color:#333333;">。</span><img loading="lazy" decoding="async" alt="" height="731" src="http://img.555519.xyz/uploads3/20220821/abf407d2d90f60275974a44a1859d372.jpg"><span style="color:#333333;">在binlog</span><span style="color:#333333;">订阅者中如果删除缓存失败，则发送一条</span><span style="color:#333333;">mq</span><span style="color:#333333;">消息到</span><span style="color:#333333;">mq</span><span style="color:#333333;">服务器，在</span><span style="color:#333333;">mq</span><span style="color:#333333;">消费者中自动重试</span><span style="color:#333333;">5</span><span style="color:#333333;">次。如果有任意一次成功，则直接返回成功。如果重试</span><span style="color:#333333;">5</span><span style="color:#333333;">次后还是失败，则该消息自动被放入死信队列，后面可能需要人工介入。</span></p> <p style="margin-left:0;text-align:justify;"> </div> 			                <div class="clearfix"></div>
                <div class="col-md-12 mt-5">
                                        <p>上一个：<a href="/news/article-51666.htm">酸辣汤的做法?(酸辣汤怎么做好喝视频)</a></p>
                                        <p>下一个：<a href="/news/article-52209.htm">长春宠物医院收费价目表查询官网（长春 宠物医院）</a></p>
                                    </div>
                                </div>
                <div class="col-md-3">
                    <div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">热门文章</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2"><a href="/free-nodes/2024-12-31-free-ssr-node.htm" title="「12月31日」最高速度19.7M/S，2025年V2ray/SSR/Clash/Shadowrocket每天更新免费机场订阅节点链接">「12月31日」最高速度19.7M/S，2025年V2ray/SSR/Clash/Shadowrocket每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-2-1-free-ssr-subscribe.htm" title="「2月1日」最高速度18.4M/S，2025年Clash/Shadowrocket/V2ray/SSR每天更新免费机场订阅节点链接">「2月1日」最高速度18.4M/S，2025年Clash/Shadowrocket/V2ray/SSR每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/news/article-19394.htm" title="1970年4月24日是什么日子（1970年4月24日出生的是什么星座）">1970年4月24日是什么日子（1970年4月24日出生的是什么星座）</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-12-13-free-high-speed-nodes.htm" title="「12月13日」最高速度21.5M/S，2024年V2ray/Shadowrocket/SSR/Clash每天更新免费机场订阅节点链接">「12月13日」最高速度21.5M/S，2024年V2ray/Shadowrocket/SSR/Clash每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/free-nodes/2025-1-28-free-node-subscribe-links.htm" title="「1月28日」最高速度20.5M/S，2025年SSR/Clash/Shadowrocket/V2ray每天更新免费机场订阅节点链接">「1月28日」最高速度20.5M/S，2025年SSR/Clash/Shadowrocket/V2ray每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/news/article-33357.htm" title="MaxCompute SQL函数详解 ODPS SQL函数详解之日期相关函数">MaxCompute SQL函数详解 ODPS SQL函数详解之日期相关函数</a></li>
                        <li class="py-2"><a href="/news/article-19852.htm" title="宠颐生官网（宠颐生团购）">宠颐生官网（宠颐生团购）</a></li>
                        <li class="py-2"><a href="/free-nodes/2024-11-18-free-subscribe-node.htm" title="「11月18日」最高速度22.7M/S，2024年SSR/Shadowrocket/V2ray/Clash每天更新免费机场订阅节点链接">「11月18日」最高速度22.7M/S，2024年SSR/Shadowrocket/V2ray/Clash每天更新免费机场订阅节点链接</a></li>
                        <li class="py-2"><a href="/news/article-45125.htm" title="打了疫苗的动物咬伤有风险么（被打过疫苗的动物咬了需要***吗）">打了疫苗的动物咬伤有风险么（被打过疫苗的动物咬了需要***吗）</a></li>
                        <li class="py-2"><a href="/news/article-43633.htm" title="宠物粮行业分析怎么写的 宠物粮行业分析怎么写的啊">宠物粮行业分析怎么写的 宠物粮行业分析怎么写的啊</a></li>
                    </ul>
    </div>
</div>

<div class="panel panel-default">
    <div class="panel-heading">
        <h3 class="panel-title">归纳</h3>
    </div>
    <div class="panel-body">
        <ul class="p-0 x-0" style="list-style: none;margin: 0;padding: 0;">
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">21</span> <a href="/date/2025-02/" title="2025-02 归档">2025-02</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">91</span> <a href="/date/2025-01/" title="2025-01 归档">2025-01</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">93</span> <a href="/date/2024-12/" title="2024-12 归档">2024-12</a></h4>
            </li>
                        <li class="py-2">
                <h4><span class="badge" style="float: right;">30</span> <a href="/date/2024-11/" title="2024-11 归档">2024-11</a></h4>
            </li>
                    </ul>
    </div>
</div>

                </div>
            </div>
        </div>
    </section>
        <footer class="ftco-footer">
        <div class="container-fluid px-0 py-5 bg-black">
            <div class="container">
                <div class="row">
                    <div class="col-md-12">
                        <p class="mb-0" style="color: rgba(255,255,255,.5);">
                            <p>
                                <a href="/">首页</a> | 
                                <a href="/free-node/">免费节点</a> | 
                                <a href="/news/">新闻资讯</a> |
                                <a href="/about-us.htm">关于我们</a> |
                                <a href="/disclaimer.htm">免责申明</a> |
                                <a href="/privacy.htm">隐私申明</a> |
                                <a href="/sitemap.xml">网站地图</a>
                            </p>
                        Node SSR节点订阅官网 版权所有
                        <br />
                        Powered by WordPress
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </footer>
    <!-- loader -->
    <div id="ftco-loader" class="show fullscreen"><svg class="circular" width="48px" height="48px">
            <circle class="path-bg" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke="#eeeeee" />
            <circle class="path" cx="24" cy="24" r="22" fill="none" stroke-width="4" stroke-miterlimit="10" stroke="#F96D00" /></svg>
    </div>
    <script src="/assets/website/js/frontend/nodessr/jquery-3.5.1.min.js"></script>
    <script src="/assets/website/js/frontend/nodessr/jquery-migrate-3.0.1.min.js"></script>
    <script src="/assets/website/js/frontend/nodessr/popper.min.js"></script>
    <script src="/assets/website/js/frontend/nodessr/bootstrap.min.js"></script>
    <script src="/assets/website/js/frontend/nodessr/jquery.easing.1.3.js"></script>
    <script src="/assets/website/js/frontend/nodessr/jquery.waypoints.min.js"></script>
    <script src="/assets/website/js/frontend/nodessr/jquery.stellar.min.js"></script>
    <script src="/assets/website/js/frontend/nodessr/owl.carousel.min.js"></script>
    <script src="/assets/website/js/frontend/nodessr/jquery.magnific-popup.min.js"></script>
    <script src="/assets/website/js/frontend/nodessr/jquery.animateNumber.min.js"></script>
    <script src="/assets/website/js/frontend/nodessr/scrollax.min.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBVWaKrjvy3MaE7SQ74_uJiULgl1JY0H2s&sensor=false"></script>
    <script src="/assets/website/js/frontend/nodessr/google-map.js"></script>
    <script src="/assets/website/js/frontend/nodessr/main.js"></script>
    <script src="https://www.freeclashnode.com/assets/js/frontend/invite-url.js"></script><script src="/assets/website/js/frontend/G.js"></script>
</body>

</html>